
# 実装計画 (ロードマップ)

LAN内アクセスを前提とした、アジャイル的な段階的開発計画です。

## Step 1: 開発環境の基盤構築 (Docker): DONE

- **やること**:
  - `Dockerfile`, `docker-compose.yml`, `requirements.txt` の作成
  - Djangoプロジェクトの作成と初期設定
- **ゴール**: `docker-compose up` コマンドで環境が立ち上がり、ブラウザでDjangoの初期画面が表示されること。

## Step 2: データモデルの設計と実装 (Backend): DONE

- **やること**:
  - `PokemonCard` モデルの定義（名称、属性、進化、枚数など）
  - データベースへのマイグレーション実行
- **ゴール**: データベース内にテーブルが作成され、データ保存の準備が整うこと。

## Step 3: 管理機能とCSV入出力の先行実装 (Admin): DONE

- **やること**:
  - Django管理画面 (Admin) の設定
  - `django-import-export` ライブラリの導入と設定
- **ゴール**: 管理画面からカード情報の登録・編集ができ、CSVでのエクスポート・インポートが動作すること。

## Step 4: 検索・一覧画面の実装 (Frontend - Read)

### 計画詳細化 (DaisyUI 導入)

DaisyUI の導入に伴い、Step4を以下の4フェーズに分けて段階的に実装します。

#### フェーズ1: フロントエンド開発環境の構築: DONE

- **目的**: DaisyUIを利用するためのCSSビルド環境 (Node.js) をDockerコンテナ内に構築し、Djangoプロジェクトと統合します。
- **やること**:
  - `Dockerfile`を更新し、Pythonに加えて`Node.js`と`npm`をインストールする。
  - `package.json`を作成し、`tailwindcss`, `daisyui`, `postcss`などの依存関係を定義する。
  - `tailwind.config.js`を作成し、DaisyUIプラグインの有効化と、監視対象のテンプレートファイルパスを設定する。
  - `docker-compose.yml`を更新し、コンテナ起動時にCSSビルドが実行されるように設定する。
  - Djangoの`settings.py`で、ビルドされたCSSが出力されるディレクトリを静的ファイルパスとして設定する。

#### フェーズ2: 基本レイアウトの作成: DONE

- **目的**: アプリケーション全体の骨格となるベーステンプレートをDaisyUIのコンポーネントで作成します。
- **やること**:
  - `templates/base.html`を作成し、DaisyUIのテーマ (`data-theme`) を設定する。
  - ヘッダー（ナビゲーションバー）、メインコンテンツ、フッターといった基本的なレイアウトをDaisyUIのクラスを用いて実装する。

#### フェーズ3: カード一覧画面の作成 (Read): DONE

- **目的**: データベース上のカード情報を、レスポンシブな一覧画面として表示します。
- **やること**:
  - `cards/views.py`に`CardListView`を作成し、全カードデータを取得するロジックを実装する。
  - `cards/urls.py`と`config/urls.py`で、一覧画面へのURLルーティングを設定する。
  - `cards/templates/cards/card_list.html`を作成し、DaisyUIの`card`コンポーネントと`grid`レイアウトを用いて、カード情報を一覧表示する。
  - フェーズ2で作成したレイアウト確認用の一時ビュー (`temp_base_view`) とURL (`/temp-base/`) を削除する。

#### フェーズ4: 検索・絞り込み機能の実装 (Filter): DONE

- **目的**: `django-filter`を導入し、キーワードや属性によるカードの絞り込み機能を追加します。
- **やること**:
  - `poetry add django-filter`コマンドでライブラリをインストールする。
  - `cards/filters.py`を新規作成し、検索条件を定義する`FilterSet`を実装する。
  - `CardListView`を改修し、GETリクエストに応じたフィルタリング処理を組み込む。
  - 一覧画面に検索フォームを設置し、`input`や`select`といった各部品をDaisyUIのコンポーネントでスタイリングする。

- **ゴール**: DaisyUIによるモダンなデザインのカード一覧画面が表示され、キーワードや属性でカードをフィルタリングできること。

## Step 5: 在庫操作と登録機能の実装 (Frontend - Write)

- **やること**: `htmx` を導入し、画面遷移なしでカードの登録・枚数増減・削除をモーダルや非同期処理で行う。
- **ゴール**: 管理画面に入らずとも、スマホ用画面だけでカードの登録・削除・枚数変更ができ、UXが大幅に向上すること。

### 計画詳細化 (`htmx`導入)

`htmx`の導入に伴い、Step5を以下の4フェーズに分けて段階的に実装します。

#### フェーズ1: `htmx`の環境構築: DONE

- **目的**: `htmx`をプロジェクトに導入し、非同期通信の準備を整えます。
- **やること**:
  - `poetry add django-htmx` を実行し、`django-htmx`をインストールします。
  - `config/settings.py` の `INSTALLED_APPS` に `'django_htmx'` を追加し、`MIDDLEWARE` に `django_htmx.middleware.HtmxMiddleware` を追加します。
  - `templates/base.html` に、`htmx.min.js` を読み込むための `<script>` タグを追加します。

#### フェーズ2: 新規登録機能の実装 (モーダル対応): DONE

- **目的**: モーダルウィンドウ内で完結するカード登録機能を作成します。
- **やること**:
  - `cards/views.py`に、フォームのHTML部品を返却するロジックと、POSTされたデータを保存して新しいカードのHTML部品を返却するロジックを持つビューを作成します。
  - `cards/urls.py`に、上記ビューに対応するURL（例: `/new/`）を定義します。
  - テンプレートの部品化:
    - `templates/cards/_card_form.html` (新規作成): カード登録フォームのみを持つHTML部品テンプレート。
    - `templates/cards/_card_item.html` (新規作成): カード1枚分の表示を担うHTML部品テンプレート。
    - `templates/cards/card_list.html` (修正): 「新規登録」ボタンに `htmx` 属性 (`hx-get`, `hx-target`) を追加し、モーダル内にフォームを呼び出すように設定。モーダル表示用のプレースホルダー `div` を配置。`htmx`が新しいカードを追加するためのターゲットとなる `div` をリストの先頭に配置。

#### フェーズ3: 枚数増減機能の実装 (非同期更新): DONE

- **目的**: 画面をリロードすることなく、カードの枚数を増減させます。
- **やること**:
  - `cards/views.py`に、枚数を更新し、更新後のカード部品 (`_card_item.html`) をHTMLとして返すビューを作成します。
  - `cards/urls.py`に、枚数増減アクション用のURL（例: `/<int:pk>/increase/`）を定義します。
  - テンプレート修正: `templates/cards/_card_item.html` 内の「+」「-」ボタンに `htmx` 属性 (`hx-post`, `hx-target`, `hx-swap`) を追加します。`hx-target` にカード自身のIDを指定し、`hx-swap="outerHTML"` を設定することで、押されたカード全体が新しい内容に置き換わるようにします。

#### フェーズ4: 削除機能の実装 (モーダル対応): DONE

- **目的**: 確認モーダルウィンドウを経て、非同期でカードを削除します。
- **やること**:
  - `cards/views.py`に、削除確認モーダルのHTML部品を返すロジックと、実際の削除処理を行うロジックを持つビューを作成します。削除が成功した場合は、中身が空のHTTPレスポンスを返します。
  - `cards/urls.py`に、上記ビューに対応するURL（例: `/<int:pk>/delete/`）を定義します。
  - テンプレートの部品化:
    - `templates/cards/_card_confirm_delete.html` (新規作成): 削除確認メッセージとボタンのみを持つHTML部品テンプレート。
    - `templates/cards/_card_item.html` (修正): 「削除」ボタンに `htmx` 属性を追加し、クリック時に確認モーダルを呼び出すように設定。削除成功時に `htmx` が要素を消せるよう、カード全体を囲む `div` にユニークなIDを付与します。

#### フェーズ5: 編集機能の実装 (モーダル対応): DONE

- **目的**: 新規登録機能と同様のモーダルウィンドウで、既存のカード情報を編集できるようにする。
- **やること**:
  - `cards/views.py`に、既存のカードデータをフォームにロードしてHTML部品を返却するロジックと、POSTされたデータを保存して更新後のカードのHTML部品を返却するロジックを持つビューを作成する。
  - `cards/urls.py`に、上記ビューに対応するURL（例: `/<int:pk>/edit/`）を定義する。
  - テンプレート修正: `templates/cards/_card_item.html` 内の「編集」ボタンに `htmx` 属性 (`hx-get`, `hx-target`) を追加し、モーダル内にフォームを呼び出すように設定。更新成功時に `htmx` が要素を置き換えられるよう、カード全体を囲む `div` にユニークなIDを付与する。

## Step 6: ソート機能の実装 (Display): DONE

- **目的**: カード一覧画面に、名前、枚数、属性、進化どあい、特徴など、複数の項目で並び替えできるソート機能を追加する。
- **やること**:
  - `django-filter`の`OrderingFilter`を利用して、ソート機能を実装する。
  - `cards/filters.py`の`CardFilter`に`OrderingFilter`を追加し、ソート可能なフィールドを定義する。
  - `CardListView` (`views.py`) がソート順のクエリパラメータを受け取れるようにする。
  - テンプレート (`card_list.html`) に、ソート順を選択するためのUI（例: ドロップダウンメニューやリンク）を設置する。各リンクには、`?o=fieldname`や`?o=-fieldname`（降順）といったクエリパラメータを含める。
- **ゴール**: ユーザーが一覧画面の表示順を自由に変更でき、目的のカードをより効率的に見つけられるようになること。

## Step 7: 画像機能と仕上げ (Optional): DONE

- **やること**:
  - モデルへの画像フィールド追加とアップロード処理の実装
  - 一覧画面への画像表示 (サムネイル)
  - Dockerボリューム設定による画像の永続化確認
- **ゴール**: カードの写真が登録でき、スマホ画面で画像付きのリストが見られること。

## Step 8: LAN内アクセス設定と実機検証 (Network): DONE

- **やること**:
  - Django設定 (`ALLOWED_HOSTS`) の変更
  - PC側のファイアウォール設定確認
  - 家族のスマホからの接続テスト
- **ゴール**: 家族のスマホからアプリにアクセスし、操作できること。

## Step 9: バッジのカスタマイズ機能の実装 (Display): DONE

- **目的**: カード一覧画面に表示されるバッジ（タイプ、特徴など）の色と並び順を、管理画面から動的に設定できるようにする。
- **やること**:
  - `Type`, `EvolutionStage`, `SpecialFeature` モデルに、色クラスを保存する `color_class` フィールドと、表示順を制御する `display_order` フィールドを追加する。
  - データベースのマイグレーションを実行する。
  - 管理画面 (`admin.py`) を修正し、新しいフィールドを編集可能にする。
  - `CardListView` (`views.py`) を修正し、`display_order` に基づいてバッジがソートされるようにクエリを調整する (`Prefetch` の利用)。
  - テンプレート (`card_list.html`) を修正し、バッジの色が `color_class` フィールドの値に基づいて動的に適用されるように変更する。
- **ゴール**: 管理画面で「炎」タイプに「赤系のバッジ」を、「水」タイプに「青系のバッジ」を割り当てるなど、非エンジニアでも直感的に表示をカスタマイズできるようになること。

## Step 10: UI/UXの改善 (Polish): DONE

- **目的**: アプリケーション全体のデザインを見直し、より洗練された使いやすいUI/UXを実現する。
- **やること**:
  - **フォーム部品の装飾**:: DONE
    - 新規登録フォームや検索フォーム内の各部品（チェックボックス、複数選択など）を、DaisyUI公式ドキュメントで紹介されているような、より装飾的で分かりやすいデザインにカスタマイズする。
    - 例えば、チェックボックスをスイッチのような見た目の「トグル（toggle）」コンポーネントに変更するなど、フィールドの種類に応じた最適なUIを検討・適用する。
    - この実現には、`cards/forms.py` や `cards/filters.py` でのウィジェット設定の高度化や、テンプレートファイル (`_card_form.html`など) でのHTML構造の調整が必要となる。
  - **アイコンの導入**:
    - 編集・削除ボタンのテキストをHeroiconsのSVGアイコンに置き換え、必要に応じてDjangoの`include`タグでアイコンをコンポーネント化する。
    - SVGパスの変更に対応できるよう、パッケージのバージョン固定などの工夫を検討する。
  - **画像編集UIの洗練**: 画像をアップロード・編集・削除するフォームのデザインを、Daisy UIベースの洗練されたデザインに変更する。
  - **デザインの調和**: 検索フォームのデザインを、カード表示コンポーネントと調和するよう、角丸や配色を調整する。: DONE
  - **全体テーマの洗練**: アプリケーション全体のカラーテーマやフォントを見直し、一貫性のあるデザインを適用する。: DONE
  - **一覧表示モードの切り替え**: 画像重視のcardタイプではなく、一画面でより多くの情報を確認できるlistタイプの表示にモード切り替えできるようにする。: DONE
  - **ページング&最上部に戻るボタン**: より多くのカードが登録された場合の閲覧性を向上させるため、ページングや、下部までスクロールしたあと最上部の検索欄へワンクリックで戻ることができるようにする。: DONE
- **ゴール**: 機能性だけでなく、見た目にも満足度の高い、直感的に操作できるアプリケーションに仕上げること。

## Step 11: 新規登録フォームの連続登録対応 (UX): DONE

- **目的**: 新規登録フォームで登録ボタンを押下した際、モーダルを閉じずに次のカードを連続して登録できるようにする。
- **やること**:
  - `cards/views.py` の新規登録ビューを修正し、登録成功後にフォームをリセットした状態のHTML部品を返すようにする。
  - `_card_form.html` テンプレートに、登録成功時のフィードバック（例: 「登録しました」というトースト通知）を表示する仕組みを追加する。
  - HTMXの `hx-swap` 属性や `HX-Trigger` レスポンスヘッダーを活用し、リスト部分には新しいカードを追加しつつ、フォーム部分は初期状態に戻すロジックを実装する。
  - 「登録して閉じる」と「登録して続ける」の2つのボタンを用意する必要はない。
- **ゴール**: 複数のカードを一度に登録する際、毎回モーダルを開き直す手間がなくなり、登録作業の効率が大幅に向上すること。

## Step 12: ポケモンカード以外の種別対応 (Data Model): DONE

- **目的**: ポケモンカードだけでなく、トレーナーズカード（道具、サポート、スタジアムなど）も管理できるようにする。
- **やること**:
  1. `PokemonCard` モデルに、カードの種別（ポケモン、道具、サポート、スタジアムなど）を識別するフィールドを追加する。
  2. 種別に応じて、関係性のないフィールド（例: 道具カードには進化段階やタイプが不要）を適切にnull許可するか、種別ごとのモデルを検討する。
  3. 管理画面 (`admin.py`) を更新し、新しいフィールドを編集可能にする。
  4. DaisyUIのtab形式で既存の検索画面とトレーナーズ検索画面を分ける。
     1. 既存の検索画面には一切手を加えないが、ポケモンしか検索されないようにフィルタする。
     2. ヘッダーは2画面統一で、メイン部分をtabで分ける。
     3. フォームでは、ポケモン画面では自動的にCardCategoryにポケモン、トレーナー図画面ではトレーナー図が入るように処理する。
  5. トレーナー図検索画面は、フォーマットは既存検索画面と統一で、検索項目やフォームの入力項目だけが異なるようにする。
- **ゴール**: ポケモンだけでなく、道具やサポートといったトレーナーズカードも同じアプリケーション内で一元管理できるようになること。

## Step 13: 関連サーチ機能の実装 (Usability): DONE

- **目的**: デッキ構築の際、あるカードの進化系統や関連カードを一覧で確認できるようにし、情報収集を効率化する。
- **やること**:
  - **UIの追加**:
    - 一覧画面の各カード（カード形式・テーブル形式）に「関連サーチ」ボタンを追加する。
    - カード形式では、編集/削除ボタンの下に配置する。
    - テーブル形式では、「詳細」ボタンと同じ列に配置する。
  - **モーダルの実装**:
    - 「関連サーチ」ボタンを押すと、関連カード一覧を表示するモーダルが表示される。
    - モーダルは、右上の「×」ボタンまたはモーダル外のクリックで閉じられるようにする。
  - **モーダル内の表示**:
    - 関連カードを「たね」「1進化」「2進化」「V進化」「M進化」などの進化段階 (`EvolutionStage`) ごとにセクション分けして表示する。
    - セクションの表示順序はEvolution Stageテーブルの表示順を用いて制御する。
    - 各セクションはテーブル形式でカード情報を表示する。
    - 該当するカードがないセクションには「ポケモンがいません」と表示する。
  - **検索ロジックの実装**:
    - ユーザー提案のロジック（対象カードのname/evolves_fromで再帰的に検索）は、実装が複雑になり、パフォーマンスの問題も懸念されます。代わりに、以下の改善案を提案します。
    - **改善案**:
      1. **進化の根を探す**: クリックされたカードから `evolves_from` を再帰的にたどり、進化系統の最も根元となる「たねポケモン」の名前 (`root_name`) を特定する。
      2. **進化系統をすべて集める**: `root_name` を起点に、関連する全てのカード名を再帰的にリストアップする。`evolves_from` をたどる際、進化先が複数ある場合（例: イーブイの進化系）でも、それらすべてを網羅的に探索します。
      3. **カードの取得**: リストアップされた名前を持つ `PokemonCard` をすべてデータベースから取得して表示する。
- **ゴール**: ユーザーが任意のカードから、その進化ライン全体をワンクリックで確認できるようになること。

## Step 14: 接続URL固定 (Network)

- **目的**: サーバーPCのIPアドレスが変動しても、毎回URLを打ち直すことなく、固定されたURLでアプリケーションにアクセスできるようにする。
- **やること**: 以下のいずれかの方式を比較検討し選択する。
  - ルーターのDHCP設定によるIPアドレス固定を検討する。
  - mDNS (Multicast DNS) を利用した `.local` ドメインでのアクセスを検討する。
  - (上級者向け) プライベートDNSサーバーの構築を検討する。
- **ゴール**: ユーザーが、固定された名前やIPアドレスで、より便利にアプリケーションにアクセスできるようになること。

## Step 15: CSV入出力機能の改善 (Usability)

- **目的**: 現在管理画面でのみ利用可能なCSV入出力機能を一般ユーザー向けに開放し、より使いやすく改善する。
- **やること**:
  - **一般ユーザー向け機能の開放**（必須）:
    - ヘッダー右上にメニューボタン（例: ハンバーガーメニュー）を配置する。
    - メニューから「CSVエクスポート」および「CSVインポート」を選択できるようにする。
    - `cards/views.py` に、CSVエクスポート用のビューとCSVインポート用のビュー（フォーム表示とアップロード処理）を作成する。
    - `cards/urls.py` に、エクスポート用URL（例: `/export/`）とインポート用URL（例: `/import/`）を定義する。
    - エクスポート機能では、現在の検索・フィルタリング条件を反映したカード一覧をCSVとしてダウンロードできるようにする。
    - インポート機能では、ファイルアップロードフォームを提供し、アップロードされたCSVを解析してデータベースに登録・更新する。
  - **CSVフォーマットの改善**（必須）:
    - エクスポートされるCSVのヘッダーを日本語化する（例: "name" → "名前"、"quantity" → "枚数"）。
    - インポート時、IDの代わりに名称（例: 「たね」「炎」）で関連データを指定できるようにする（ファイル内で参照可能なものも含む）。
  - **ユーザビリティ向上**:
    - CSVインポート機能に関するヘルプ画面を設ける（優先度: 中）。
    - インポート用のCSVフォーマット例（サンプルデータ入り）をダウンロードできる機能を設ける（優先度: 低）。
- **ゴール**: 非エンジニアでも管理画面にアクセスすることなく、メイン画面からCSVファイルを直感的に編集・利用できるようになり、データメンテナンス性が向上すること。

## Step 16: お気に入りフラグ機能の実装 (Grouping)

- **目的**: デッキ構築やユーザーごとのグルーピングに活用できる、カスタマイズ可能なマーカー機能を提供する。
- **やること**:
  - `FavoriteFlag` モデルを新規作成し、フラグ番号（1～5）、名称、色クラス、表示順などのフィールドを定義する。
  - `PokemonCard` モデルに、`FavoriteFlag` への ManyToMany リレーションを追加する。
  - データベースのマイグレーションを実行する。
  - 管理画面 (`admin.py`) に `FavoriteFlag` を登録する。
  - メイン画面でのフラグ設定機能を実装する:
    - ナビゲーションバーに「設定」リンクまたはアイコンを追加する。
    - `cards/views.py` に、フラグ設定画面を表示するビューと、設定を保存するビューを作成する。
    - `cards/urls.py` に、設定画面用のURL（例: `/settings/flags/`）を定義する。
    - 設定画面用のテンプレート（例: `flag_settings.html`）を作成し、5つのフラグの名称と色を編集できるフォームを提供する。
    - HTMXを活用し、フォーム送信後に非同期で保存し、成功メッセージを表示する。
  - フォーム (`cards/forms.py`) を修正し、カード登録・編集時にお気に入りフラグを選択できるようにする。
  - フィルタ (`cards/filters.py`) を修正し、お気に入りフラグによる絞り込み機能を追加する。
  - テンプレート (`_card_item.html`, `_card_form.html`) を修正し、お気に入りフラグをバッジとして表示する。
  - 一覧画面で、お気に入りフラグのオン/オフを非同期で切り替えられるUI（例: クリックでトグル）を検討する。
- **ゴール**: ユーザーが管理画面にアクセスせず、メイン画面の設定ページから自由に名称を設定できる5つのフラグを使って、デッキ構築や用途別のカード管理が効率的に行えるようになること。
